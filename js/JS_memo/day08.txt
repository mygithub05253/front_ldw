window
- onload : 웹 브라우저가 열렸으면, 즉 로드된 이후에 실행
=> onLoad에 함수를 정의하는 방식은 브라우저 엔진에게 부담을 줌
=> onLoad는 명확히 해당 브라우저가 실행되고 나서 실행되어야 하는 로직을 작성

프로그램
- 실행되고 있지 않은 상태

프로세스
- 실행되고 있는 상태

스레드
- 비동기식 방식으로 특정 연산을 수행할 때 업무를 효율적으로 처리하기 위해 짧은 시간 안에 다양한 연산들을 마치 동시에 처리하는 것처럼 하는 것들을 할 수 있도록 하는 것
- ex) 쿨타임, 유튜브 보고 있는 경우, 무한 스크롤 등

단일 스레드
- 처리 경로를 한 개만 가지고 있기 때문에 직렬적
- 동시에 많은 양을 처리하기 힘들기 때문에 상대적으로 비효율적
- 하지만 하나의 작업에 문제가 발생하더라도 다른 작업에는 영향 없음
- 안정성이 보장되고 설계 시 멀티 스레드보다 쉬움

멀티 스레드
=> 스레드는 단일로 시작해서 그 이후에 처리 경로가 나뉨
- 하나의 프로세스를 동시에 처리하는 것처럼 보이짐나 사실 매우 짧은 단위로 분할해서 차례대로 수행
- 여러 개의 처리 경로를 가질 수 있도록 하며, 동시에 작업 가능
- 설계하기 굉장히 어렵고, 하나의 스레드에 문제 발생 시 모든 스레드에 문제 발생
- 멀티 스레드로 설계했다면, 처리량 증가, 효율성 증가, 처리 비용 감소의 장점이 있기 때문에 단점을 감수하고 설계함

자바스크립트는 단일 스레드(코드를 처리할 수 있는 일꾼 하나)
=> 자바스크립트는 이벤트 루프(Node)를 활용하여 테스크가 종료되지 않아도 곧바로 실행하는 함수를 이용하여 처리하는 방식 도입

동기
- 페이지
- 코드를 순차적으로 읽는 흐름

비동기
- 데이터
- 처리시간이 각각 다르기 때문에 결과 예상 불가능

=> 결과에 따라 다음 비동기 이후 실행된 동기적 함수를 실행시키기 위하여 비동기를 동기적으로 처리하는 작업 필요

* 결론
1) 동기와 비동기는 다름(두 개의 흐름이 다름)
2) 비동기 안에서도 동기의 흐름 존재
3) 비동기는 비동기만의 흐름 따로 존재
4) 동기를 비동기로, 비동기를 동기로 바꿔야 합류 가능

=========================================================
axios, fetch
fetch(ES6 내장 API)
- 기존의 web에서는 비동기 요청을 보내기 위해서 XML, HTML, REQUEST(XHT) 객체를 생성했어야 함
- 이러한 XHR의 요청의 상태나 변경에 따라 개발자의 의도에 맞게 사용하는 것이 어려워서 이를 보완하기 위해 http 요청에 최적화되고 추상화되어 있는 API 생성되기 시작
- 대표적으로 axios와 fetch
- 단점 : 데이터의 요청 및 응답 데이터 수신 시 json 데이터를 받아올 수 없어서 파싱하는 작업 필요
- .json() : json -> string
- JSON.stringfy : string -> json



































